-- Migration: Lexicon Tables (Vocabulary Rebuild - Step 1)
-- Creates lexicon_entries, lexicon_senses, lexicon_translations, lexicon_examples, lexicon_verb_forms
-- Date: 2025-02-23
-- 
-- Lexicon = global cache of lexical knowledge
-- Created exclusively by AI enrichment
-- Single source of truth for word meanings

-- ============================================
-- TABLE: lexicon_entries (lemma + POS)
-- ============================================
create table if not exists lexicon_entries (
  id uuid primary key default gen_random_uuid(),
  lemma text not null, -- normalized lemma (lowercase, trimmed)
  lemma_norm text not null, -- same as lemma, for consistency
  pos text not null, -- part of speech: 'noun', 'verb', 'adjective', 'adverb', etc. (from AI only)
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint lexicon_entries_lemma_norm_unique unique (lemma_norm)
);

create index if not exists idx_lexicon_entries_lemma_norm on lexicon_entries(lemma_norm);
create index if not exists idx_lexicon_entries_pos on lexicon_entries(pos);

-- ============================================
-- TABLE: lexicon_senses (meanings/definitions)
-- ============================================
create table if not exists lexicon_senses (
  id uuid primary key default gen_random_uuid(),
  entry_id uuid not null references lexicon_entries(id) on delete cascade,
  definition_en text not null, -- English definition of this sense
  domain text, -- optional: 'business', 'sports', 'academic', etc. (nullable)
  sense_order int not null default 0, -- order within entry (0, 1, 2, ...)
  created_at timestamptz not null default now(),
  constraint lexicon_senses_entry_order_unique unique (entry_id, sense_order)
);

create index if not exists idx_lexicon_senses_entry_id on lexicon_senses(entry_id);
create index if not exists idx_lexicon_senses_domain on lexicon_senses(domain);

-- ============================================
-- TABLE: lexicon_translations (PL translations per sense)
-- ============================================
create table if not exists lexicon_translations (
  id uuid primary key default gen_random_uuid(),
  sense_id uuid not null references lexicon_senses(id) on delete cascade,
  translation_pl text not null, -- Polish translation for this specific sense
  created_at timestamptz not null default now(),
  constraint lexicon_translations_sense_unique unique (sense_id) -- one PL translation per sense
);

create index if not exists idx_lexicon_translations_sense_id on lexicon_translations(sense_id);

-- ============================================
-- TABLE: lexicon_examples (pool of examples per sense)
-- ============================================
create table if not exists lexicon_examples (
  id uuid primary key default gen_random_uuid(),
  sense_id uuid not null references lexicon_senses(id) on delete cascade,
  example_en text not null, -- example sentence in English
  source text not null default 'ai', -- 'ai' (generated by OpenAI)
  example_hash text, -- hash for duplicate detection (optional)
  created_at timestamptz not null default now(),
  last_used_at timestamptz, -- for LRU rotation (nullable)
  constraint lexicon_examples_sense_hash_unique unique (sense_id, example_hash) -- prevent exact duplicates
);

create index if not exists idx_lexicon_examples_sense_id on lexicon_examples(sense_id);
create index if not exists idx_lexicon_examples_last_used on lexicon_examples(last_used_at);
create index if not exists idx_lexicon_examples_created_at on lexicon_examples(created_at);

-- ============================================
-- TABLE: lexicon_verb_forms (verb conjugations)
-- ============================================
create table if not exists lexicon_verb_forms (
  id uuid primary key default gen_random_uuid(),
  entry_id uuid not null references lexicon_entries(id) on delete cascade,
  present_simple_i text not null, -- "I work"
  present_simple_you text not null, -- "you work"
  present_simple_he_she_it text not null, -- "he/she/it works"
  past_simple text not null, -- "worked" or irregular "went"
  past_participle text not null, -- "worked" or irregular "gone"
  created_at timestamptz not null default now(),
  constraint lexicon_verb_forms_entry_unique unique (entry_id) -- one set of forms per verb entry
);

create index if not exists idx_lexicon_verb_forms_entry_id on lexicon_verb_forms(entry_id);

-- ============================================
-- RLS POLICIES
-- ============================================

-- Lexicon tables are READ-ONLY for authenticated users
-- INSERT/UPDATE only via backend with service role (no direct user writes)

alter table lexicon_entries enable row level security;
alter table lexicon_senses enable row level security;
alter table lexicon_translations enable row level security;
alter table lexicon_examples enable row level security;
alter table lexicon_verb_forms enable row level security;

-- SELECT: All authenticated users can read lexicon (it's a cache)
do $$
begin
  if not exists (
    select 1 from pg_policies
    where schemaname = 'public' and tablename = 'lexicon_entries' and policyname = 'Lexicon entries: authenticated select'
  ) then
    create policy "Lexicon entries: authenticated select"
      on lexicon_entries
      for select
      using (auth.uid() is not null);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public' and tablename = 'lexicon_senses' and policyname = 'Lexicon senses: authenticated select'
  ) then
    create policy "Lexicon senses: authenticated select"
      on lexicon_senses
      for select
      using (auth.uid() is not null);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public' and tablename = 'lexicon_translations' and policyname = 'Lexicon translations: authenticated select'
  ) then
    create policy "Lexicon translations: authenticated select"
      on lexicon_translations
      for select
      using (auth.uid() is not null);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public' and tablename = 'lexicon_examples' and policyname = 'Lexicon examples: authenticated select'
  ) then
    create policy "Lexicon examples: authenticated select"
      on lexicon_examples
      for select
      using (auth.uid() is not null);
  end if;

  if not exists (
    select 1 from pg_policies
    where schemaname = 'public' and tablename = 'lexicon_verb_forms' and policyname = 'Lexicon verb forms: authenticated select'
  ) then
    create policy "Lexicon verb forms: authenticated select"
      on lexicon_verb_forms
      for select
      using (auth.uid() is not null);
  end if;
end
$$;

-- INSERT/UPDATE/DELETE: Only via service role (backend API routes)
-- No RLS policies for INSERT/UPDATE/DELETE - service role bypasses RLS
